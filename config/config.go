// Copyright 2017~2022 The Bottos Authors
// This file is part of the Bottos Chain library.
// Created by Rocket Core Team of Bottos.

//This program is free software: you can distribute it and/or modify
//it under the terms of the GNU General Public License as published by
//the Free Software Foundation, either version 3 of the License, or
//(at your option) any later version.

//This program is distributed in the hope that it will be useful,
//but WITHOUT ANY WARRANTY; without even the implied warranty of
//MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
//GNU General Public License for more details.

//You should have received a copy of the GNU General Public License
// along with bottos.  If not, see <http://www.gnu.org/licenses/>.

/*
 * file description:  config load
 * @Author: Gong Zibin
 * @Date:   2017-12-11
 * @Last Modified by:
 * @Last Modified time:
 */

package config

import (
	"bytes"
	"encoding/json"
	"fmt"
	"github.com/bottos-project/bottos/bpl"
	"github.com/bottos-project/bottos/cmd"
	"github.com/bottos-project/bottos/common"
	log "github.com/cihub/seelog"
	cli "gopkg.in/urfave/cli.v1"
	"io/ioutil"
	"os"
	"strings"
	"time"
)

const (
	// DefaultConfigPath is definition of config file name
	DefaultConfigPath = "./chainconfig.json"
	DefaultRESTPort   = 8689
	DefaultRESTServer = "localhost"
	DefaultRPCPort    = 8690
	DefaultRPCServer  = "localhost"
	DefaultP2PPort    = 9868
)

const (
	DefaultGenesisKey = "0454f1c2223d553aa6ee53ea1ccea8b7bf78b8ca99f3ff622a3bb3e62dedc712089033d6091d77296547bc071022ca2838c9e86dec29667cf740e5c9e654b6127f"
)

var (
	// Param general config parameter
	Param Parameter
	// Genesis genesis config
	Genesis GenesisConfig
	// ChainID chain id generated by genesis config
	ChainID common.Hash
)

// Parameter is definition of config param
type Parameter struct {
	GenesisJson       string    `json:"genesis_json"`
	DataDir           string    `json:"data_dir"`
	RESTPort          int       `json:"rest_port"`
	RESTServAddr      string    `json:"rest_serv_addr"`
	P2PPort           int       `json:"p2p_port"`
	P2PServAddr       string    `json:"p2p_serv_addr"`
	PeerList          []string  `json:"peer_list"`
	KeyPairs          []KeyPair `json:"key_pairs"`
	Delegates         []string  `json:"delegates"`
	DelegateSignKey   KeyPair   `json:"delegate_signkey"`
	RpcServiceName    string    `json:"rpc_service_name"`
	RpcServiceVersion string    `json:"rpc_service_version"`
	EnableStaleReport bool      `json:"enable_stale_report"`
	OptionDb          string    `json:"option_db"`
	LogConfig         string    `json:"log_config"`
}

// KeyPair is definition of key pair
type KeyPair struct {
	PrivateKey string `json:"private_key"`
	PublicKey  string `json:"public_key"`
}

// GenesisConfig is definition of genesis config
type GenesisConfig struct {
	GenesisTime   uint64
	GenesisKey    []byte
	InitDelegates []InitDelegate
}

// InitDelegate is definition of init delegate
type InitDelegate struct {
	Name      string `json:"name"`
	PublicKey string `json:"public_key"`
	Balance   string `json:"balance"`
}

func InitConfig() {
	initParam()
	initGenesis()
}

func initParam() {
	Param.GenesisJson = "./genesis.json"
	Param.DataDir = "./datadir/"
	Param.RESTPort = DefaultRESTPort
	Param.P2PPort = DefaultP2PPort
	Param.P2PServAddr = "192.168.1.1"
	Param.RESTServAddr = DefaultRESTServer
	Param.PeerList = []string{}
	Param.KeyPairs = []KeyPair{
		{
			PrivateKey: "b799ef616830cd7b8599ae7958fbee56d4c8168ffd5421a16025a398b8a4be45",
			PublicKey:  "0454f1c2223d553aa6ee53ea1ccea8b7bf78b8ca99f3ff622a3bb3e62dedc712089033d6091d77296547bc071022ca2838c9e86dec29667cf740e5c9e654b6127f",
		},
	}
	Param.Delegates = []string{}
	Param.RpcServiceName = "bottos"
	Param.RpcServiceVersion = "3.0.0"
	Param.EnableStaleReport = true
	Param.OptionDb = ""
	Param.LogConfig = "./corelog.xml"
}

func initGenesis() {
	var err error
	Genesis.GenesisTime, err = timeFromRFC3339("2018-08-01T12:00:00Z")
	if err != nil {
		fmt.Printf("Genesis time parse error: %v", err)
		os.Exit(1)
	}
	Genesis.GenesisKey, err = common.HexToBytes(DefaultGenesisKey)
	if err != nil {
		fmt.Printf("Genesis key parse error: %v", err)
		os.Exit(1)
	}
	data, _ := bpl.Marshal(Genesis)
	ChainID = common.DoubleSha256(data)
}

func GetChainID() []byte {
	return ChainID[:]
}

func loadConfigFile(fn string) error {
	f, err := os.Open(fn)
	if err != nil {
		return err
	}
	defer f.Close()

	err = toml.NewDecoder(bufio.NewReader(f)).Decode(&BtoConfig)
	if _, ok := err.(*toml.LineError); ok {
		err = errors.New(fn + ", " + err.Error())
	}
	return err
}

func loadGenesisFile(fn string) error {
	file, e := loadConfigJson(fn)
	if e != nil {
		return fmt.Errorf("Load genesis file error: ", e)
	}

	type genesisStruct struct {
		GenesisTime   string         `json:"genesis_time"`
		GenesisKey    string         `json:"genesis_key"`
		InitDelegates []InitDelegate `json:"init_delegates"`
	}
	gs := genesisStruct{}
	e = json.Unmarshal(file, &gs)
	if e != nil {
		return fmt.Errorf("Parse genesis file error: %v", e)
	}

	var err error
	Genesis.GenesisTime, err = timeFromRFC3339(gs.GenesisTime)
	if err != nil {
		fmt.Printf("Genesis time parse error: %v", err)
		os.Exit(1)
	}
	Genesis.GenesisKey, err = common.HexToBytes(gs.GenesisKey)
	if err != nil {
		fmt.Printf("Genesis key parse error: %v", err)
		os.Exit(1)
	}
	Genesis.InitDelegates = make([]InitDelegate, len(gs.InitDelegates))
	copy(Genesis.InitDelegates, gs.InitDelegates)

	data, _ := bpl.Marshal(Genesis)
	ChainID = common.DoubleSha256(data)

	return nil
}

func timeFromRFC3339(ts string) (uint64, error) {
	if !strings.HasSuffix(ts, "Z") {
		ts += "Z"
	}
	gt, e := time.Parse(time.RFC3339, ts)
	if e != nil {
		return 0, fmt.Errorf("Parse genesis time error: %v", e)
	}

	return uint64(gt.Unix()), nil
}

// LoadConfig is to load config file
func LoadConfig(ctx *cli.Context) error {
	configFn := DefaultConfigPath
	if ctx.GlobalIsSet(cmd.ConfigFileFlag.Name) {
		configFn = ctx.GlobalString(cmd.ConfigFileFlag.Name)
	}
	if err := loadConfigFile(configFn); err != nil {
		return err
	}

	genesisFn := Param.GenesisJson
	if ctx.GlobalIsSet(cmd.GenesisFileFlag.Name) {
		genesisFn = ctx.GlobalString(cmd.GenesisFileFlag.Name)
	}
	if err := loadGenesisFile(genesisFn); err != nil {
		return err
	}
	Param.GenesisJson = genesisFn

	if ctx.GlobalIsSet(cmd.DataDirFlag.Name) {
		Param.DataDir = ctx.GlobalString(cmd.DataDirFlag.Name)
	}

	if ctx.GlobalIsSet(cmd.LogConfigFlag.Name) {
		Param.LogConfig = ctx.GlobalString(cmd.LogConfigFlag.Name)
	}

	if ctx.GlobalIsSet(cmd.RESTPortFlag.Name) {
		Param.RESTPort = ctx.GlobalInt(cmd.RESTPortFlag.Name)
		if _, err := PortValidate(Param.RESTPort); err != nil {
			return err
		}
	}

	if ctx.GlobalIsSet(cmd.RESTServerAddrFlag.Name) {
		Param.RESTServAddr = ctx.GlobalString(cmd.RESTServerAddrFlag.Name)
	}

	if ctx.GlobalIsSet(cmd.P2PPortFlag.Name) {
		Param.P2PPort = ctx.GlobalInt(cmd.P2PPortFlag.Name)
		if _, err := PortValidate(Param.P2PPort); err != nil {
			return err
		}
	}

	if ctx.GlobalIsSet(cmd.P2PServerAddrFlag.Name) {
		Param.P2PServAddr = ctx.GlobalString(cmd.P2PServerAddrFlag.Name)
		if _, err :=IpValidate(Param.P2PServAddr); err != nil {
			return err
		}
	}

	if ctx.GlobalIsSet(cmd.RPCPortFlag.Name) {
		//Param.RPCPort = ctx.GlobalInt(cmd.RPCPortFlag.Name)
	}

	if ctx.GlobalIsSet(cmd.DelegateFlag.Name) {
		d := ctx.GlobalString(cmd.DelegateFlag.Name)
		Param.Delegates = []string{d}
	}

	if ctx.GlobalIsSet(cmd.MongoDBFlag.Name) {
		Param.OptionDb = ctx.GlobalString(cmd.MongoDBFlag.Name)
		if _, err := MongoUrlValidate(Param.OptionDb); err != nil {
			return err
		}
	}

	if ctx.GlobalIsSet(cmd.EnableStaleReportFlag.Name) {
		Param.EnableStaleReport = ctx.GlobalBool(cmd.EnableStaleReportFlag.Name)
	}

	if ctx.GlobalIsSet(cmd.PeerListFlag.Name) {
		raw := ctx.GlobalString(cmd.PeerListFlag.Name)
		peerList, err := parsePeerListCLI(raw)
		if err != nil {
			return fmt.Errorf("parse peerlist error")
		}
		Param.PeerList = make([]string, len(peerList))
		copy(Param.PeerList, peerList)
		if _, err :=IpValidateAll(Param.PeerList); err != nil {
			return err
		}
	}

	if ctx.GlobalIsSet(cmd.DelegateSignkeyFlag.Name) {
		raw := ctx.GlobalString(cmd.DelegateSignkeyFlag.Name)
		keypair, err := parseKeyPairCLI(raw)
		if err != nil {
			return err
		}
		Param.DelegateSignKey = keypair
		if _, err := SignKeyValidate(Param.DelegateSignKey.PrivateKey, Param.DelegateSignKey.PublicKey); err != nil {
			return err
		}
	}

	return nil
}


func GetDelegateSignKey(pubkey string) ([]byte, error) {
	if pubkey == BtoConfig.Delegate.Signature.PublicKey {
		return common.HexStringToBytes(BtoConfig.Delegate.Signature.PrivateKey), nil
	}

	return nil, fmt.Errorf("Not Found")
}


func parsePeerListCLI(raw string) ([]string, error) {
	var peerList []string
	val := strings.Replace(raw, " ", "", -1)
	peerList = strings.Split(val, ",")
	// check peers
	return peerList, nil
}

func parseKeyPairCLI(raw string) (KeyPair, error) {
	val := strings.Replace(raw, " ", "", -1)
	keys := strings.Split(val, ",")
	if len(keys) < 2 {
		return KeyPair{}, fmt.Errorf("parse delegate sign key error")
	}
	keypair := KeyPair{}
	keypair.PrivateKey = keys[0]
	keypair.PublicKey = keys[1]
	// check key
	return keypair, nil
}

// InitLogConfig initialize log config
func InitLogConfig(ctx *cli.Context) error {
	if ctx.GlobalIsSet(cmd.LogConfigFlag.Name) {
		Param.LogConfig = ctx.GlobalString(cmd.LogConfigFlag.Name)
	}

	defer log.Flush()
	logger, err := log.LoggerFromConfigAsFile(Param.LogConfig)
	if err != nil {
		return fmt.Errorf("parse log config file error: ", err)
	}
	log.ReplaceLogger(logger)
	return nil
}

func loadConfigJson(fn string) ([]byte, error) {
	file, e := ioutil.ReadFile(fn)
	if e != nil {
		return nil, e
	}

	// Remove the UTF-8 Byte Order Mark
	file = bytes.TrimPrefix(file, []byte("\xef\xbb\xbf"))
	return file, nil
}
